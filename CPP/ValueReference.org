#+TITLE: 左值引用与右值引用
#+DATE: 2025-06-08 20:22:34
#+DISPLAY: t
#+STARTUP: indent
#+OPTIONS: toc:10
#+AUTHOR: inmove
#+CATEGORIES: CPP

* 左值引用与右值引用
左值引用: 用&来声明的变量，必须绑定到已存在的变量上，是另一个变量的别名
右值引用: 用&&来声明的变量，通常是字面量，临时对象或者表示式的值
#+begin_src cpp
  int main() {
    // 左值引用
    int a = 10;
    int &b = a;

    // 右值引用
    int &&c = 10;

    // error: cannot bind rvalue reference of type 'int &&' to lvalue of type int
    // int a   = 10;
    // int &&r = a;

    return 0;
  }
#+end_src

* 右值引用

** 移动构造函数
#+begin_src cpp
  #include <iostream>
  using namespace std;

  class MyVector {
      int *data;
      size_t size;

     public:
      // 构造函数
      MyVector(size_t s) : size(s), data(new int[s]) { cout << "Construct: " << s << endl; }

      // 析构函数
      ~MyVector()
      {
          delete[] data;
          cout << "Destruct\n";
      }

      // 复制构造函数
      MyVector(const MyVector& other)
          : size(other.size) {
          data = new int[size];
          for (size_t i = 0; i < size; ++i)
              data[i] = other.data[i];
      }

      MyVector(MyVector &&other) noexcept : data(other.data), size(other.size)
      {
          other.data = nullptr;  // 防止 double-free
          other.size = 0;
          cout << "Move Construct\n";
      }
  };

  int main()
  {
      MyVector v1(1000);
      MyVector v2 = std::move(v1);  // 移动构造
      MyVector v3 = MyVector(v2);  // 复制构造

      return 0;
  }

#+end_src

类中，默认复制构造函数是参数是一个对象的左引用，移动构造函数则是右引用。
在不同的场景下有不同的作用。当我们知道原对象不再使用时，使用 std::move 移动构造函数就会被调用。
比如函数中返回局部变量的时候，在 *移动语义* 出现之前会进行复制，如果对象占用的资源比较大，复制会有很大的开销。
std::move的作用就是将左值引用变为右值引用，那么根据函数重载的原理，赋值给v2时，移动构造函数会被调用。

* 万能引用
#+begin_src cpp
  template <typename T>
  void func1(T&& v) {}

  void func2(int&& v) {}
#+end_src
事例代码中，参数都是右值引用的形式，但是它们是有本质区别的
1. func1 又叫 *万能引用* 既可以用右值引用作为实参，也可以用左值引用做为实参。
2. func2 只能是右值引用
** 引用折叠
#+begin_src cpp
  template <typename T>
  void func(T&& v){}

  int main() {
    int a = 10;
    func(a);
    func(10);
    return 0;
  }
#+end_src
1. func(a): T 为 int&，所以 T&& 就变成了 int& &&，折叠为 int&
2. func(10): T 为 int&&，T&& 变成了 int&& &&，折叠为 int&&

引用折叠规则如下：
T& & -> T&
T& && -> T&
T&& & -> T&
T&& && -> T&&
只要有一个是左值引用，结果就是左值引用

** 完美转发
#+begin_src cpp
  #include <iostream>
  using namespace std;

  template <typename T>
  void func(T&& v) {}

  template <typename T>
  void func1(T&& v) {func(v);}

  template <typename T>
  void func2(T&& v) {func(forward<T>(v));}

  int main() {
    func1(10);
    func2(10);
    return 0;
  }
#+end_src
根据引用折叠的规则，func1中，v应该是一个右值引用，但是它有了一个变量名v，所以在传到func中时，实参是一个左值引用
在func2中使用了 forward<T> ，它的作用就是保持参数的引用特性。
